import java.util.*;
/*******
 * 
Write a program to find the nth super ugly number.

Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32] is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of size 4.

Note:
	(1) 1 is a super ugly number for any given primes.
	(2) The given numbers in primes are in ascending order.
	(3) 0 < k ≤ 100, 0 < n ≤ 106, 0 < primes[i] < 1000.

 * 
 * */

// 类似题： Le_264

public class Q313_Super_Ugly_Number {
	// solution 1: using priorityqueue, time is O(nlogk), space is O(k)
	public int nthSuperUglyNumber(int n, int[] primes) {
        if(n <= 0 || primes == null || primes.length == 0) {
			return -1;
		}
	    
	    Queue<Pair> heap = new PriorityQueue<Pair>(primes.length, new Comparator<Pair>() {
	        @Override
	        public int compare(Pair p1, Pair p2) {
	            return p1.value - p2.value;
	        }
	    });
	    
	    int[] ugly = new int[n];
	    ugly[0] = 1;
	    
	    // time is O(klogk)
	    for(int prime : primes) {
	        heap.offer(new Pair(prime, 0, prime));
	    }
	    
	    // time is O(nlogk)
	    for(int i = 1; i < n; i++) {     // 从1开始 ！！！
	        ugly[i] = heap.peek().value;
	        
	        // remove duplicated num
	        while(heap.peek().value == ugly[i]) {
	            Pair p = heap.poll();
	            heap.offer(new Pair(ugly[p.index + 1] * p.prime, p.index + 1, p.prime));
	        }
	    }
	    
	    return ugly[n - 1];
    }
    
    class Pair {
        int value;
        int index;
        int prime;
        
        public Pair(int value, int index, int prime) {
            this.value = value;
            this.index = index;
            this.prime = prime;
        }
    }
	
	
	
	/**** 
	 * Basic idea is same as ugly number II, new ugly number is generated by multiplying a prime with previous generated ugly number. 
	 * One catch is need to remove duplicate
	 **/
	
	// solution 2: time is O(k*n), space is O(k)
	public int nthSuperUglyNumber2(int n, int[] primes) {
		if(n <= 0 || primes == null || primes.length == 0) {
			return -1;
		}
		
        int[] ugly = new int[n];
        int[] index = new int[primes.length];  // store index of ugly
        int[] value = new int[primes.length];  // store value of ugly
        Arrays.fill(value, 1);
        int nextUgly = 1;
        
        for (int i = 0; i < n; i++) {
            ugly[i] = nextUgly;            
            nextUgly = Integer.MAX_VALUE;
            
            for (int j = 0; j < primes.length; j++) {
                //skip duplicate and avoid extra multiplication
                if (value[j] == ugly[i]) {
                	value[j] = ugly[index[j]] * primes[j];
                	index[j]++;
                }
                
                //find next ugly number
                nextUgly = Math.min(nextUgly, value[j]);
            }
        }

        return ugly[n - 1];
    }
}
