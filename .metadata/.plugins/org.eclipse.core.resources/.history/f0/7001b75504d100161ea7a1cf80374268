
public class Q302_Smallest_Rectangle_Enclosing_Black_Pixels {
	public int minArea(char[][] image, int x, int y) {
        if(image == null || image.length == 0 || image[0].length == 0) {
            return 0;
        }    
        
        int left = Integer.MAX_VALUE, right = Integer.MIN_VALUE, up = Integer.MAX_VALUE, down = Integer.MIN_VALUE;
        int row = image.length, col = image[0].length;
        
        for(int i = 0; i < row; i++) {
            int[] ans = searchCol(image, i);
            
            if(ans[0] == -1) {
            	continue;
            }
            
            left = Math.min(left, ans[0]);
            right = Math.max(right, ans[1]);
        }
        
        System.out.println("1:" + left + " " + right);
        
        for(int i = 0; i < col; i++) {
            int[] ans = searchRow(image, i);
            
            if(ans[0] == -1) {
            	continue;
            }
            
            up = Math.min(up, ans[0]);
            down = Math.max(down, ans[1]);
            System.out.println(ans[0] + " " + ans[1]);
        }
        
        System.out.println("2:" + up + " " + down);
        
        return (right - left + 1) * (down - up + 1);
    }
    
    public int[] searchCol(char[][] image, int rowIndex) {
        int left = 0, right = image[0].length - 1;
        int[] ans = new int[2];
        
        while(left + 1 < right) {
            int mid = left + (right - left) / 2;
            
            if(image[rowIndex][mid] == '0') {
                left = mid;
            } else {
                right = mid;
            }
        }
        
        if(image[rowIndex][left] == '1') {
        	ans[0] = left;
        } else if(image[rowIndex][right] == '1') {
        	ans[0] = right;
        } else {
        	ans[0] = -1;
        	ans[1] = -1;
        	return ans;
        }
        
        left = ans[0];
        right = image[0].length - 1;
        
        while(left + 1 < right) {
            int mid = left + (right - left) / 2;
            
            if(image[rowIndex][mid] == '0') {
                right = mid;
            } else {
                left = mid;
            }
        }
        
        if(image[rowIndex][right] == '1') {
        	ans[1] = right;
        } else if(image[rowIndex][left] == '1') {
        	ans[1] = left;
        } else {
        	ans[0] = -1;
        	ans[1] = -1;
        }
        return ans;
    }
    
    public int[] searchRow(char[][] image, int colIndex) {
        int up = 0, down = image.length - 1;
        int[] ans = new int[2];
        
        while(up + 1 < down) {
            int mid = up + (down - up) / 2;
            
            if(image[mid][colIndex] == '0') {
                up = mid;
            } else {
                down = mid;
            }
        }
        
        if(image[up][colIndex] == '1') {
        	ans[0] = up;
        } else if(image[down][colIndex] == '1') {
        	ans[0] = down;
        } else {
        	ans[0] = -1;
        	ans[1] = -1;
        	return ans;
        }
        
        up = ans[0];
        down = image.length - 1;
        
        while(up + 1 < down) {
            int mid = up + (down - up) / 2;
            
            if(image[mid][colIndex] == '0') {
                down = mid;
            } else {
                up = mid;
            }
        }
        
        if(image[down][colIndex] == '1') {
        	ans[1] = down;
        } else if(image[up][colIndex] == '1') {
        	ans[1] = up;
        } else {
        	ans[0] = -1;
        	ans[1] = -1;
        }
        return ans;
    }
	
	
    
    
    public static void main(String[] args) {
    	Q302_Smallest_Rectangle_Enclosing_Black_Pixels t = new Q302_Smallest_Rectangle_Enclosing_Black_Pixels();
    	String[] strs = {"0010","0000", "0000"};
    	
    	char[][] image = {
    			strs[0].toCharArray(),
    			strs[1].toCharArray(),
    			strs[2].toCharArray()
    	};
    	
    	System.out.println(t.minArea(image, 0, 2));
    }
    
    
	
//	// by other using binary search, O(n * lgm + m * lgn)
//	public int minArea(char[][] image, int x, int y) {
//	    int row = image.length, col = image[0].length;
//	    int left = searchColumns(image, 0, y, 0, row, true);
//	    int right = searchColumns(image, y, col, 0, row, false);
//	    int top = searchRows(image, 0, x, left, right, true);
//	    int bottom = searchRows(image, x, row, left, right, false);
//	    return (right - left) * (bottom - top);
//	}
//	
//	public int searchColumns(char[][] image, int left, int right, int top, int bottom, boolean opt) {
//	    while (left < right) {
//	        int k = top, mid = (left + right) / 2;
//	        
//	        while (k < bottom && image[k][mid] == '0') {
//	        	++k;
//	        }
//	        
//	        if (k < bottom == opt) { // 表示找到
//	            right = mid;
//	        } else {
//	            left = mid + 1;     // 注意这里要 ＋1 ！！！
//	        }
//	    }
//	    
//	    return left;
//	}
//	
//	public int searchRows(char[][] image, int top, int bottom, int left, int right, boolean opt) {
//	    while (top < bottom) {
//	        int k = left, mid = (top + bottom) / 2;
//	        
//	        while (k < right && image[mid][k] == '0') {
//	        	++k;
//	        }
//	        
//	        if (k < right == opt) {  // 表示找到
//	            bottom = mid;
//	        } else {
//	            top = mid + 1;      // 注意这里要 ＋1 ！！！
//	        }
//	    }
//	    
//	    return top;
//	}
	
	
	
	/*****************************************************************/
	// by Jackie using DFS, but exceed time limit
	private int left = 0, right = 0, up = 0, down = 0;
    
    public int minArea2(char[][] image, int x, int y) {
        if(image == null || image.length == 0 || image[0].length == 0){
            return 0;
        }
        
        int row = image.length, col = image[0].length;
        left = right = y;
        up = down = x;
        boolean[][] visited = new boolean[row][col];
        
        traver(image, visited, x, y);
        return (right - left + 1) * (up - down + 1);
    }
    
    public void traver(char[][] image, boolean[][] visited, int x, int y){
        if(visited[x][y] == true){
            return;
        }
        
        visited[x][y] = true;
        left = Math.min(left, y);
        right = Math.max(right, y);
        up = Math.max(up, x);
        down = Math.min(down, x);
        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};
        
        for(int i = 0; i < 4; i++){
            int newX = x + dx[i];
            int newY = y + dy[i];
            
            if(newX >= 0 && newX < image.length && newY >= 0 && newY < image[0].length && image[newX][newY] == '1'){
                traver(image, visited, newX, newY);
            }
        }
    }
}
