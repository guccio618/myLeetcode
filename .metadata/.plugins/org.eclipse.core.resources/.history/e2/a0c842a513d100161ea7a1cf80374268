
public class Q302_Smallest_Rectangle_Enclosing_Black_Pixels {
	// solution 2: using binary search, time is O(m*logn + n*logm);
	public int minArea(char[][] image, int x, int y) {
	    int left = findMinBound(image, 0, y, true);
	    int right = findMaxBound(image, y, image[0].length - 1, true);
	    int top = findMinBound(image, 0, x, false);
	    int bottom = findMaxBound(image, x, image.length - 1, false);
	    return (right - left + 1) * (bottom - top + 1);
	}

	public int findMinBound(char[][] image, int min, int max, boolean horizontal) {
	    while (min < max) {
	        int mid = min + (max - min) / 2;
	        if (!hasBlack(image, mid, horizontal)) {
	            min = mid + 1;
	        } else {
	            max = mid;
	        }
	    }	    
	    return min;
	}

	public int findMaxBound(char[][] image, int min, int max, boolean horizontal) {
	    while (min < max) {
	        int mid = min + (max - min + 1) / 2;
	        if (!hasBlack(image, mid, horizontal)) {
	            max = mid - 1;
	        } else {
	            min = mid;
	        }
	    }
	    return max;
	}

	public boolean hasBlack(char[][] image, int mid, boolean horizontal) {
	    if (horizontal) {
	        for (int i = 0; i < image.length; i++) {
	            if (image[i][mid] == '1') {
	                return true;
	            }
	        }
	    } else {
	        for (int j = 0; j < image[0].length; j++) {
	            if (image[mid][j] == '1') {
	                return true;
	            }
	        }
	    }	    
	    return false;
	}
	
    
	
	
	
	
	
	
	
	/*************************** main function ************************************/
	
    public static void main(String[] args) {
    	Q302_Smallest_Rectangle_Enclosing_Black_Pixels t = new Q302_Smallest_Rectangle_Enclosing_Black_Pixels();
    	String[] strs = {"0010","0000", "0000"};
    	
    	char[][] image = {
    			strs[0].toCharArray(),
    			strs[1].toCharArray(),
    			strs[2].toCharArray()
    	};
    	
    	System.out.println(t.minArea3(image, 0, 2));
    }
    
    
	
    // solution 2: using binary search, time is O(n * lgm + m * lgn)
	public int minArea2(char[][] image, int x, int y) {
		int row = image.length, col = image[0].length;
	    int left = searchColumns(image, 0, row, 0, y, true);
	    int right = searchColumns(image, 0, row, y, col, false);
	    int top = searchRows(image, 0, x, left, right, true);
	    int bottom = searchRows(image, x, row, left, right, false);
	    return (right - left) * (bottom - top);
	}
	
	public int searchColumns(char[][] image, int top, int bottom, int left, int right, boolean forward) {
	    while (left < right) {
	        int k = top, mid = (left + right) / 2;
	        
	        while (k < bottom && image[k][mid] == '0') {
	        	++k;
	        }
	        
	        if (k < bottom == forward) {     // 表示找到, 用等号 ！！！
	            right = mid;
	        } else {
	            left = mid + 1;              // 注意这里要 ＋1 ！！！
	        }
	    }
	    
	    return left;
	}
	
	public int searchRows(char[][] image, int top, int bottom, int left, int right, boolean forward) {
	    while (top < bottom) {
	        int k = left, mid = (top + bottom) / 2;
	        
	        while (k < right && image[mid][k] == '0') {
	        	++k;
	        }
	        
	        if (k < right == forward) {  // 表示找到
	            bottom = mid;
	        } else {
	            top = mid + 1;      // 注意这里要 ＋1 ！！！
	        }
	    }
	    
	    return top;
	}
	
	
	
	/*****************************************************************/
	// by Jackie using DFS, but exceed time limit
	private int left = 0, right = 0, up = 0, down = 0;
    
    public int minArea2(char[][] image, int x, int y) {
        if(image == null || image.length == 0 || image[0].length == 0){
            return 0;
        }
        
        int row = image.length, col = image[0].length;
        left = right = y;
        up = down = x;
        boolean[][] visited = new boolean[row][col];
        
        traver(image, visited, x, y);
        return (right - left + 1) * (up - down + 1);
    }
    
    public void traver(char[][] image, boolean[][] visited, int x, int y){
        if(visited[x][y] == true){
            return;
        }
        
        visited[x][y] = true;
        left = Math.min(left, y);
        right = Math.max(right, y);
        up = Math.max(up, x);
        down = Math.min(down, x);
        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};
        
        for(int i = 0; i < 4; i++){
            int newX = x + dx[i];
            int newY = y + dy[i];
            
            if(newX >= 0 && newX < image.length && newY >= 0 && newY < image[0].length && image[newX][newY] == '1'){
                traver(image, visited, newX, newY);
            }
        }
    }
}
