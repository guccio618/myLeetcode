import java.util.PriorityQueue;
import java.util.Comparator;
import java.util.Arrays;

public class test {
	public static Cpoint[] findKClose_heap(Cpoint[] list, int k) {
		if(list == null || list.length == 0) {
			return new Cpoint[0];
		} else if(k >= list.length) {
			return list;
		}
		
		Cpoint[] ans = new Cpoint[k];
		
		PriorityQueue<Cpoint> maxHeap = new PriorityQueue<Cpoint>(k + 1, new Comparator<Cpoint>() {
			@Override 
			public int compare(Cpoint p1, Cpoint p2) {
				return -Double.compare(Math.sqrt(p1.x*p1.x + p1.y*p1.y), Math.sqrt(p2.x*p2.x + p2.y*p2.y));
			}
		});
		
		for(Cpoint p : list) {
			maxHeap.offer(p);
			
			if(maxHeap.size() > k) {
				maxHeap.poll();
			}
		}		
		
		for(int i = k - 1; i >= 0 && !maxHeap.isEmpty(); i--) {
			ans[i] = maxHeap.poll();
		}
		
		return ans;
	}

	
	public static Cpoint[] findKClose_sort(Cpoint[] list, int k) {
		if(list == null || list.length == 0) {
			return new Cpoint[0];
		} else if(k >= list.length) {
			return list;
		}
		
		Cpoint[] newList = new Cpoint[list.length];
		
		for(int i = 0; i < list.length; i++) {
			newList[i] = list[i];
		}
		
		Arrays.sort(newList, new Comparator<Cpoint>() {
			@Override
			public int compare(Cpoint p1, Cpoint p2) {
				return Double.compare(Math.sqrt(p1.x*p1.x + p1.y*p1.y), Math.sqrt(p2.x*p2.x + p2.y*p2.y));
			}
		});
		
		Cpoint[] ans = new Cpoint[k];
		
		for(int i = 0; i < k; i++) {
			ans[i] = newList[i];
		}
		
		return ans;
	}


	public static String longestPalindrome(String s) {
		if(s == null || s.length() <= 1) {
			return s;
		}
		
		Pair p = new Pair(0, 0);
		
		for(int i = 0; i < s.length() - 1; i++) {
			getPalindrome(p, s, i, i);
			getPalindrome(p, s, i, i+1);
		}
		
		return s.substring(p.startIndex, p.startIndex + p.maxLen);
	}

	public static void getPalindrome(Pair p, String s, int start, int end) {
		while(start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end)) {
			start--;
			end++;	
		}
		
		if(end - start - 1 > p.maxLen) {
			p.maxLen = end - start - 1;
			p.startIndex = start + 1;
		}
	}


	static class Pair {
		int startIndex;
		int maxLen;
		
		public Pair(int startIndex, int maxLen) {
			this.startIndex = startIndex;
			this.maxLen = maxLen;
		}
	}
	
	
	

	public static void main(String[] args) {
		Cpoint[] list = new Cpoint[7];
		int k = 3;
	
		for (int i = list.length - 1; i >= 0; i--) {
			list[i] = new Cpoint(-i-1, i+1);
		}

		Cpoint[] array = findKClose_sort(list, k);
	
		for(Cpoint p : array) {
			System.out.println(p.toString());
		}
		
		
		String str = "ddabccba";
		System.out.println(longestPalindrome(str));
		String str2 = "ddabcba";
		System.out.println(longestPalindrome(str2));
	}
}