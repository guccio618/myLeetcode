/*****************************************************************************
 * 以下几种方案适合用动态规划：
 * 		(1). 求最大／最小值
 * 		(2). 判断是否可行
 * 		(3). 统计方案个数 (非具体方案，否则通常用search)
 * 		(4). 当输入的数据是一个集合而不是序列时，不使用动规
 * 
 * 四大要素：
 * 		State, Function, Initialization, Answer
 * 
 * 记忆化搜索：适用于
 * 			(1). 状态转移方程特别麻烦，非顺序性
 * 			(2). 初始化状态不是很容易找到
 * 			(3). 记忆化搜索可以用 memo[i] != null 或者 memo[i] + visited[i]来判断
 * 				 是否已经计算过。
 * 
 * ——————————————————————————————————————————————————————————————————————————————
 * 题型分类：
 * 
 * 区间DP: 此类题目共性就是区间最后求[0,n-1] 这样一个区间 逆向思维分析 从大到小就能迎刃而解
 * 		  类似分治法
 * 		  题目： Le_087*, 396， 476， 312
 * 
 * 表达式匹配： Le_010, Le_044
 * 
 * 字符串对比类: Le_010, Le_044, Le_072, Le_097, Le_115, Le_392*, Le_115* (初始化)
 * 
 * 字符串查找类：Le_131*, Le_132*, Le_139*, Le_140*, *li_77, *li_79,  
 * 
 * 查找最大正方形，矩形，对角正方形: Le_084, Le_085, Le_221*(求最大的对角矩阵面积),  
 * 
 * 博弈类: Le_293, Le_294*, li_394, **li_395, **li_396
 * 
 * 区间类：Le_087*, Le_312*, Le_375*, li_396*, li_476*
 * 
 * 背包问题: Le_474*, li_89*, li_92, li_125, li_440
 * 
 * 单调栈：Le_084, Le_085	
 * 
 * 连续增加子串类: **300, *315(Count of Smaller Numbers After Self), *329, *li_77, *li_79, *li_397, 
 * 
 * 连续子串最大和／乘积: 53, 152
 * 
 * 股票买卖： Le_121, Le_122, Le_123, Le_188*, Le_309
 * 
 * 最小和第二小值： Le_256, Le_265*, Le_276
 * 
 * 交替DP: Le_152, Le_376*( O(n)方法 ), li_397
 * 
 * 可以用DP和binary search： Le_300*
 *  
 * 
 * 重点题型： leetcode: 10, *32, 44, 53, 72, 84, 85, *87, 91, 95,
 * 				    96, 97, *115(初始化), 120, 123, *131, *132, *139 + *140两种不同的解法, 152, *188, 
 * 					213, 221*(求最大的对角矩阵面积), 263, *264, *265, 276, 279, *300的 O(nlogn) 方法，*312, 329简化方法,
 *  				*343, *351, *354的O(nlogn)方法, *357, *361, *363, *368, *375, 376*, 392, 
 *  				403*, 413*, 418*, 474*, li_476*
 * 			
 * 			lintcode: 77, 79, *89, *91, 92, 125, *440, *395, *396, 398, *476 			
 *   
 *****************************************************************************/

public class Datastructure_Definition {
	
}																																											

class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;
	TreeNode(int x) { val = x; }
}

class TreeLinkNode {
    TreeLinkNode left;
    TreeLinkNode right;
    TreeLinkNode next;
  }
